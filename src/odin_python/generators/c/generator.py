from io import StringIO
from typing import Literal

import csnake as cc
from pydantic import BaseModel, Field

from ..abstract_generator import AbstractGenerator, ModelContext
from ...parameter.parameter import (
    C_Names,
)
from .objects import (
    to_group_initialiser,
    to_object_initialiser,
    to_object_type,
    to_variable_initialiser,
    to_variable_type,
)


class CGenerator(AbstractGenerator):
    class Config(BaseModel):
        objects_type: str = "odin_objects_t"
        objects_name: str = "odin_objects"
        variables_type: str = "odin_variables_t"
        variables_name: str = "odin_variables"
        groups_name: str = "odin_store"

        extra_includes: list[str] = Field(
            default_factory=list,
        )
        header_file_name: str = Field(
            default="OD.h",
        )
        src_file_name: str = Field(
            default="OD.c",
        )

        @property
        def types(self) -> C_Names:
            return C_Names(
                objects_name=self.objects_name,
                objects_type=self.objects_type,
                variables_name=self.variables_name,
                variables_type=self.variables_type,
                groups_name=self.groups_name,
            )

    config: Config

    def __init__(self, config: Config):
        super().__init__(config)
        self.config = config

    def generate(  # type: ignore
        self,
        model_context: ModelContext,
        output_path: str | StringIO,
        type: Literal["header", "source", "single_source"] = "header",
        **kwargs: dict[str, str],
    ) -> None:
        if type == "header":
            data = self.generate_header(model_context)
        elif type == "source":
            data = self.generate_source(model_context)
        elif type == "single_source":
            data = self.generate_header(model_context) + "\n" + self.generate_source(model_context, no_include=True)
        else:
            raise ValueError(f"Unknown type: {type}")

        self.save_to_file(output_path, data)

    def add_code_generation_disclaimer(self, cw: cc.CodeWriter) -> None:
        cw.add_line("// This file is generated by Odin Python C generator.")
        cw.add_line("// Do not edit this file directly.")
        cw.add_line("// If you want to make changes, edit the .yaml file and regenerate the code.")
        cw.add_line("")
        cw.add_line("// Generated by Odin Python C generator")
        cw.add_line("//")
        cw.add_line("")

    def generate_source(self, model_context: ModelContext, no_include: bool = False) -> str:
        cw = cc.CodeWriter()
        self.add_code_generation_disclaimer(cw)

        if not no_include:
            cw.add_line(f'#include "{self.config.header_file_name}"')
            cw.add_line("")

        model_context.root_model.initialise_types(self.config.types)

        # Generate the ram storage type
        initaliser = to_variable_initialiser(model_context.root_model)

        if initaliser is not None:
            cw.add_variable_initialization(initaliser)  # type: ignore
            cw.add_line("")

        value = to_object_initialiser(model_context.root_model)

        value.qualifiers = ["const"]
        cw.add_variable_initialization(value)
        cw.add_line("")

        values = to_group_initialiser(model_context.root_model)

        for value in values:
            value.qualifiers = ["const"]
            cw.add_variable_initialization(value)
            cw.add_line("")

        if model_context.collections is not None:
            for collection_name, collection in model_context.collections.items():
                cw.add_line(f"// Collection: {collection_name}")

                values = to_group_initialiser(collection)
                for value in values:
                    value.qualifiers = ["const"]
                    cw.add_variable_initialization(value)
                    cw.add_line("")

        return str(cw)

    def generate_header(self, model_context: ModelContext) -> str:
        cw = cc.CodeWriter()
        self.add_code_generation_disclaimer(cw)
        cw.add_line("#include <stdint.h>")
        cw.add_line("#include <stdbool.h>")
        cw.add_line("#include <odin.h>")
        cw.add_line("#include <odin_core.h>")
        cw.add_line("#include <odin_security.h>")

        for include in self.config.extra_includes:
            cw.add_line(f'#include "{include}"')

        # Add include guard
        cw.add_line(f"#ifndef {self.config.header_file_name.upper().replace('.', '_')}_H")
        cw.add_line(f"#define {self.config.header_file_name.upper().replace('.', '_')}_H")
        cw.add_line("")

        # model_context.root_model.initialise_types(self.config.types)

        # Create odin variables struct
        variable_type = to_variable_type(model_context.root_model)
        if variable_type is not None:
            cw.add_struct(variable_type)

        cw.add_line("")

        cw.add_struct(to_object_type(model_context.root_model))
        cw.add_line("")

        # Generate acces control definitions
        for line in model_context.root_model.to_access_control_header():
            cw.add_line(line)

        # Add external references
        initaliser = to_variable_initialiser(model_context.root_model)
        if initaliser is not None:
            cw.add_variable_declaration(initaliser, extern=True)

        value = to_object_initialiser(model_context.root_model)
        value.qualifiers = ["const"]

        cw.add_variable_declaration(
            value,
            extern=True,
        )

        for value in to_group_initialiser(model_context.root_model):
            value.qualifiers = ["const"]
            cw.add_variable_declaration(
                value,
                extern=True,
            )

        if model_context.collections is not None:
            for collection_name, collection in model_context.collections.items():
                values = to_group_initialiser(collection)
                for value in values:
                    value.qualifiers = ["const"]
                    cw.add_variable_declaration(
                        value,
                        extern=True,
                    )

        cw.add_line("")
        cw.add_line("#endif /* {model.header_name.upper()}_H */")
        cw.add_line("")
        return str(cw)
